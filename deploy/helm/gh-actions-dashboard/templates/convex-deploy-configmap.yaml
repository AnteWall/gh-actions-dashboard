{{- if and .Values.convex.enabled .Values.convex.deploy.enabled }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "gh-actions-dashboard.fullname" . }}-convex-functions
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "gh-actions-dashboard.labels" . | nindent 4 }}
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-weight": "-5"
    "helm.sh/hook-delete-policy": before-hook-creation
data:
  schema.ts: |
    import { defineSchema, defineTable } from "convex/server";
    import { v } from "convex/values";

    // GitHub Actions Dashboard Schema
    export const workflowRunStatus = v.union(
      v.literal("requested"),
      v.literal("in_progress"),
      v.literal("completed"),
      v.literal("queued"),
      v.literal("waiting"),
      v.literal("pending")
    );

    export const workflowRunConclusion = v.union(
      v.literal("success"),
      v.literal("failure"),
      v.literal("neutral"),
      v.literal("cancelled"),
      v.literal("timed_out"),
      v.literal("action_required"),
      v.literal("stale"),
      v.literal("skipped"),
      v.literal("startup_failure")
    );

    export default defineSchema({
      // Store repository information
      repositories: defineTable({
        owner: v.string(),
        name: v.string(),
        fullName: v.string(), // "owner/repo"
        avatarUrl: v.optional(v.string()),
        htmlUrl: v.string(),
      }).index("by_full_name", ["fullName"]),

      // Store workflow run information
      workflowRuns: defineTable({
        // GitHub identifiers
        runId: v.number(), // GitHub's workflow run ID
        runNumber: v.number(),
        runAttempt: v.number(),

        // Repository reference
        repositoryId: v.id("repositories"),
        repositoryFullName: v.string(), // Denormalized for easier queries

        // Workflow info
        workflowId: v.number(),
        workflowName: v.string(),
        displayTitle: v.string(),

        // Status
        status: workflowRunStatus,
        conclusion: v.optional(workflowRunConclusion),

        // Branch and commit info
        headBranch: v.string(),
        headSha: v.string(),
        event: v.string(), // "push", "pull_request", etc.

        // Actor info
        actorLogin: v.string(),
        actorAvatarUrl: v.optional(v.string()),

        // Timestamps (stored as ISO strings from GitHub)
        createdAt: v.string(),
        updatedAt: v.string(),
        runStartedAt: v.optional(v.string()),

        // URL to view on GitHub
        htmlUrl: v.string(),
      })
        .index("by_repository", ["repositoryId"])
        .index("by_repository_full_name", ["repositoryFullName"])
        .index("by_run_id", ["runId"])
        .index("by_status", ["status"]),
    });

  queries.ts: |
    import { query } from "./_generated/server";
    import { v } from "convex/values";

    // Get all repositories with their latest workflow runs grouped by workflow
    export const listRepositoriesWithRuns = query({
        args: {},
        handler: async (ctx) => {
            const repositories = await ctx.db.query("repositories").collect();

            const repositoriesWithRuns = await Promise.all(
                repositories.map(async (repo) => {
                    const runs = await ctx.db
                        .query("workflowRuns")
                        .withIndex("by_repository", (q) => q.eq("repositoryId", repo._id))
                        .order("desc")
                        .take(50); // Get more runs to group by workflow

                    // Group runs by workflow
                    const workflowMap = new Map<number, {
                        workflowId: number;
                        workflowName: string;
                        runs: typeof runs;
                    }>();

                    for (const run of runs) {
                        const existing = workflowMap.get(run.workflowId);
                        if (existing) {
                            // Keep only last 10 runs per workflow
                            if (existing.runs.length < 10) {
                                existing.runs.push(run);
                            }
                        } else {
                            workflowMap.set(run.workflowId, {
                                workflowId: run.workflowId,
                                workflowName: run.workflowName,
                                runs: [run],
                            });
                        }
                    }

                    const workflows = Array.from(workflowMap.values()).sort((a, b) => {
                        // Sort by most recent run
                        const aLatest = a.runs[0]?.updatedAt ?? "";
                        const bLatest = b.runs[0]?.updatedAt ?? "";
                        return bLatest.localeCompare(aLatest);
                    });

                    return {
                        repository: repo,
                        workflows,
                    };
                })
            );

            // Sort by most recent activity
            return repositoriesWithRuns.sort((a, b) => {
                const aLatest = a.workflows[0]?.runs[0]?.updatedAt ?? "";
                const bLatest = b.workflows[0]?.runs[0]?.updatedAt ?? "";
                return bLatest.localeCompare(aLatest);
            });
        },
    });

    // Get a single repository with its runs
    export const getRepositoryWithRuns = query({
        args: {
            fullName: v.string(),
        },
        handler: async (ctx, args) => {
            const repository = await ctx.db
                .query("repositories")
                .withIndex("by_full_name", (q) => q.eq("fullName", args.fullName))
                .first();

            if (!repository) {
                return null;
            }

            const runs = await ctx.db
                .query("workflowRuns")
                .withIndex("by_repository", (q) => q.eq("repositoryId", repository._id))
                .order("desc")
                .take(10);

            return {
                ...repository,
                runs,
            };
        },
    });

    // Get dashboard summary stats
    export const getDashboardStats = query({
        args: {},
        handler: async (ctx) => {
            const allRuns = await ctx.db.query("workflowRuns").collect();
            const repositories = await ctx.db.query("repositories").collect();

            // Get the latest run per repository to determine current status
            const latestRunsByRepo = new Map<string, (typeof allRuns)[0]>();
            for (const run of allRuns) {
                const existing = latestRunsByRepo.get(run.repositoryFullName);
                if (!existing || run.updatedAt > existing.updatedAt) {
                    latestRunsByRepo.set(run.repositoryFullName, run);
                }
            }

            const latestRuns = Array.from(latestRunsByRepo.values());

            const stats = {
                totalRepositories: repositories.length,
                totalRuns: allRuns.length,
                successCount: latestRuns.filter((r) => r.conclusion === "success").length,
                failureCount: latestRuns.filter((r) => r.conclusion === "failure").length,
                inProgressCount: latestRuns.filter(
                    (r) => r.status === "in_progress" || r.status === "queued" || r.status === "waiting"
                ).length,
                cancelledCount: latestRuns.filter((r) => r.conclusion === "cancelled").length,
            };

            return stats;
        },
    });

    // Get runs that are currently in progress
    export const getInProgressRuns = query({
        args: {},
        handler: async (ctx) => {
            const inProgressRuns = await ctx.db
                .query("workflowRuns")
                .withIndex("by_status", (q) => q.eq("status", "in_progress"))
                .collect();

            const queuedRuns = await ctx.db
                .query("workflowRuns")
                .withIndex("by_status", (q) => q.eq("status", "queued"))
                .collect();

            const waitingRuns = await ctx.db
                .query("workflowRuns")
                .withIndex("by_status", (q) => q.eq("status", "waiting"))
                .collect();

            return [...inProgressRuns, ...queuedRuns, ...waitingRuns].sort(
                (a, b) => b.updatedAt.localeCompare(a.updatedAt)
            );
        },
    });

  workflowRuns.ts: |
    import { v } from "convex/values";
    import { mutation, internalMutation } from "./_generated/server";
    import { workflowRunStatus, workflowRunConclusion } from "./schema";

    // Maximum number of runs to keep per repository
    const MAX_RUNS_PER_REPO = 10;

    // Upsert a repository - creates if not exists, updates if exists
    export const upsertRepository = mutation({
        args: {
            owner: v.string(),
            name: v.string(),
            fullName: v.string(),
            avatarUrl: v.optional(v.string()),
            htmlUrl: v.string(),
        },
        handler: async (ctx, args) => {
            const existing = await ctx.db
                .query("repositories")
                .withIndex("by_full_name", (q) => q.eq("fullName", args.fullName))
                .first();

            if (existing) {
                await ctx.db.patch(existing._id, {
                    owner: args.owner,
                    name: args.name,
                    avatarUrl: args.avatarUrl,
                    htmlUrl: args.htmlUrl,
                });
                return existing._id;
            }

            return await ctx.db.insert("repositories", args);
        },
    });

    // Insert or update a workflow run
    export const upsertWorkflowRun = mutation({
        args: {
            runId: v.number(),
            runNumber: v.number(),
            runAttempt: v.number(),
            repositoryFullName: v.string(),
            workflowId: v.number(),
            workflowName: v.string(),
            displayTitle: v.string(),
            status: workflowRunStatus,
            conclusion: v.optional(workflowRunConclusion),
            headBranch: v.string(),
            headSha: v.string(),
            event: v.string(),
            actorLogin: v.string(),
            actorAvatarUrl: v.optional(v.string()),
            createdAt: v.string(),
            updatedAt: v.string(),
            runStartedAt: v.optional(v.string()),
            htmlUrl: v.string(),
            // Repository info for upsert
            repositoryOwner: v.string(),
            repositoryName: v.string(),
            repositoryAvatarUrl: v.optional(v.string()),
            repositoryHtmlUrl: v.string(),
        },
        handler: async (ctx, args) => {
            // First, ensure the repository exists
            let repository = await ctx.db
                .query("repositories")
                .withIndex("by_full_name", (q) => q.eq("fullName", args.repositoryFullName))
                .first();

            if (!repository) {
                const repoId = await ctx.db.insert("repositories", {
                    owner: args.repositoryOwner,
                    name: args.repositoryName,
                    fullName: args.repositoryFullName,
                    avatarUrl: args.repositoryAvatarUrl,
                    htmlUrl: args.repositoryHtmlUrl,
                });
                repository = await ctx.db.get(repoId);
            }

            if (!repository) {
                throw new Error("Failed to create or find repository");
            }

            // Check if this run already exists
            const existingRun = await ctx.db
                .query("workflowRuns")
                .withIndex("by_run_id", (q) => q.eq("runId", args.runId))
                .first();

            const runData = {
                runId: args.runId,
                runNumber: args.runNumber,
                runAttempt: args.runAttempt,
                repositoryId: repository._id,
                repositoryFullName: args.repositoryFullName,
                workflowId: args.workflowId,
                workflowName: args.workflowName,
                displayTitle: args.displayTitle,
                status: args.status,
                conclusion: args.conclusion,
                headBranch: args.headBranch,
                headSha: args.headSha,
                event: args.event,
                actorLogin: args.actorLogin,
                actorAvatarUrl: args.actorAvatarUrl,
                createdAt: args.createdAt,
                updatedAt: args.updatedAt,
                runStartedAt: args.runStartedAt,
                htmlUrl: args.htmlUrl,
            };

            if (existingRun) {
                // Update existing run
                await ctx.db.patch(existingRun._id, runData);
            } else {
                // Insert new run
                await ctx.db.insert("workflowRuns", runData);

                // Cleanup old runs - keep only the last MAX_RUNS_PER_REPO per repository
                const allRuns = await ctx.db
                    .query("workflowRuns")
                    .withIndex("by_repository", (q) => q.eq("repositoryId", repository._id))
                    .order("desc")
                    .collect();

                if (allRuns.length > MAX_RUNS_PER_REPO) {
                    const runsToDelete = allRuns.slice(MAX_RUNS_PER_REPO);
                    for (const run of runsToDelete) {
                        await ctx.db.delete(run._id);
                    }
                }
            }
        },
    });

    // Internal mutation for cleanup (can be scheduled)
    export const cleanupOldRuns = internalMutation({
        args: {},
        handler: async (ctx) => {
            const repositories = await ctx.db.query("repositories").collect();

            for (const repo of repositories) {
                const runs = await ctx.db
                    .query("workflowRuns")
                    .withIndex("by_repository", (q) => q.eq("repositoryId", repo._id))
                    .order("desc")
                    .collect();

                if (runs.length > MAX_RUNS_PER_REPO) {
                    const runsToDelete = runs.slice(MAX_RUNS_PER_REPO);
                    for (const run of runsToDelete) {
                        await ctx.db.delete(run._id);
                    }
                }
            }
        },
    });

  tsconfig.json: |
    {
      "compilerOptions": {
        "allowJs": true,
        "strict": true,
        "moduleResolution": "Bundler",
        "jsx": "react-jsx",
        "skipLibCheck": true,
        "allowSyntheticDefaultImports": true,
        "target": "ESNext",
        "lib": ["ES2021", "dom"],
        "forceConsistentCasingInFileNames": true,
        "module": "ESNext",
        "isolatedModules": true,
        "noEmit": true
      },
      "include": ["./**/*"],
      "exclude": ["./_generated"]
    }

  package.json: |
    {
      "name": "convex-deploy",
      "private": true,
      "scripts": {
        "deploy": "convex deploy"
      },
      "dependencies": {
        "convex": "^1.21.0"
      }
    }
{{- end }}
